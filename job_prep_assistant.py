# -*- coding: utf-8 -*-
"""Job_prep_assistant.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gVDv8FcRH7gZ7Sk4QADpEzvtak3R3eXV
"""

from IPython.display import Markdown

Markdown("""
# Job Prep Assistant

This notebook helps you:
- Upload your resume and a job description
- Parse & compare them using Google Gemini embeddings
- Show similarity score
- Get resume feedback powered by Gemini 2.5 Pro Experimental Model

---
""")

!pip install -q nltk

import nltk
nltk.download('punkt')
nltk.download('stopwords')
nltk.download('punkt_tab')

from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
import string

def extract_keywords(text):
    tokens = word_tokenize(text.lower())
    words = [word for word in tokens if word.isalpha()]
    stop_words = set(stopwords.words('english'))
    keywords = [w for w in words if w not in stop_words and len(w) > 2]
    return set(keywords)

!pip install -q google-generativeai PyMuPDF python-docx scikit-learn

!pip install -q google-generativeai PyMuPDF python-docx scikit-learn

import google.generativeai as genai

genai.configure(api_key=st.secrets["GEMINI_API_KEY"])

from google.colab import files
import fitz  # PyMuPDF
import docx
import os

def upload_and_extract():
    uploaded = files.upload()
    file_name = list(uploaded.keys())[0]

    ext = os.path.splitext(file_name)[-1].lower()
    text = ""

    if ext == ".pdf":
        doc = fitz.open(file_name)
        text = "\n".join([page.get_text() for page in doc])
    elif ext == ".docx":
        doc = docx.Document(file_name)
        text = "\n".join([para.text for para in doc.paragraphs])
    elif ext == ".txt":
        with open(file_name, "r", encoding="utf-8") as f:
            text = f.read()
    else:
        text = "‚ùå Unsupported file format."

    return text, file_name

print("üìÑ Upload your **Resume** file:")
resume_text, resume_filename = upload_and_extract()

print("‚úÖ Resume uploaded and extracted.")
print(resume_text[:1000])  # Preview first 1000 characters

# Paste your job description below as a string
job_text = """
What You Will Do

Let‚Äôs do this! Let‚Äôs change the world! In this vital role you will [top-line statement connecting primary position responsibility to employer brand].

Adheres to strict documentation practices in a GMP regulated environment
Engineering competency in all conventional aspects of the subject matter, functional area, and assignments
Plans and performs work, independently evaluating, selecting, and adapting standard methods, and creating new solutions to engineering problems.
Authors and reviews technical documentation including protocols, reports, and technical assessments
Coordinates and executes laboratory testing to support characterization, verification, and design transfer activities
Analyzes and trend generated data by applying relevant statistical techniques
Maintains device and combination product design history files for assigned products
Ensure test methods and test protocols are developed in a sound and robust framework with high focus on eliminating test errors
Provides functional subject matter expertise to actively participate in cross-functional activities including system level root cause analysis, design changes, and change control assessments
Lead teams in the implementation for process improvement initiatives
Works with Scientists and Engineers, to assess and develop appropriate design and manufacturing specifications
Provides training and ongoing support to team members and internal stakeholders on the use of digital tools, promoting continuous learning and development within the team.
Oversees the maintenance of a digital thread across testing and data analytics, ensuring comprehensive integration and accessibility of data throughout combination product.
Utilizes and drives Agile project methodologies throughout the project lifecycle, ensuring flexible, efficient, and effective project management and implementation.
Engages with internal and external stakeholders to understand their challenges and requirements, tailoring digital solutions to meet these specific needs.
Executes complex data queries to extract, clean, and manipulate data from various sources, ensuring the data is usable for detailed analysis and reporting.

"""

embedding_model = genai.GenerativeModel("models/embedding-001")

import google.generativeai as genai

# üîê Replace with your real API key
genai.configure(api_key=st.secrets["GEMINI_API_KEY"])


def get_embedding(text):
    response = genai.embed_content(
        model="models/embedding-001",
        content=text,
        task_type="RETRIEVAL_DOCUMENT"
    )
    return response['embedding']

resume_embedding = get_embedding(resume_text)
job_embedding = get_embedding(job_text)

from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

def get_match_score(embedding1, embedding2):
    return cosine_similarity([embedding1], [embedding2])[0][0]

score = get_match_score(resume_embedding, job_embedding)
print(f"üîç Resume-to-JD Match Score: {score*100:.2f}%")

from IPython.display import Markdown

Markdown(f"### ‚úÖ **Resume Match Score: {score*100:.2f}%**")

gemini_pro = genai.GenerativeModel("models/gemini-2.5-pro-exp-03-25")

def get_resume_feedback(resume_text, job_text):
    prompt = f"""
You are a job application expert. Compare the following **resume** and **job description**.

Resume:
{resume_text}

Job Description:
{job_text}

Based on this comparison, provide:
1. A match score (0 to 100) ‚Äî your own estimate.
2. Skills or experiences missing in the resume.
3. Resume formatting or clarity improvements.
4. A short paragraph summarizing key suggestions.

Respond in clear, professional English.
"""
    response = gemini_pro.generate_content(prompt)
    return response.text

gemini_2 = genai.GenerativeModel("gemini-2.5-pro-exp-03-25")

def get_resume_feedback_v2(resume_text, job_text):
    prompt = f"""
You are a job application expert. Compare the following **resume** and **job description**.

Resume:
{resume_text}

Job Description:
{job_text}

Based on this comparison, provide:
1. A match score (0 to 100) ‚Äî your own estimate.
2. Skills or experiences missing in the resume.
3. Resume formatting or clarity improvements.
4. A short paragraph summarizing key suggestions.

Respond in clear, professional English.
"""
    response = gemini_2.generate_content(prompt)
    return response.text

feedback = get_resume_feedback_v2(resume_text, job_text)
print(feedback)

with open("resume_feedback.txt", "w") as f:
    f.write(f"Match Score: {score*100:.2f}%\n\n")
    f.write(feedback)

from IPython.display import HTML, display

def highlight_missing_keywords(jd_text, resume_text):
    jd_keywords = extract_keywords(jd_text)
    resume_keywords = extract_keywords(resume_text)

    missing = jd_keywords - resume_keywords
    present = jd_keywords & resume_keywords

    html = "<h4>üîç <u>Job Description Keywords Match:</u></h4><br><p>"
    for word in sorted(jd_keywords):
        if word in present:
            html += f"<span style='color:green; font-weight:bold;'>{word}</span> "
        else:
            html += f"<span style='color:black;'>{word}</span> "
    html += "</p><br><hr><p><b>Legend:</b> <span style='color:green;'>‚úîÔ∏è Present</span> | <span style='color:black;'>‚ùå Missing</span></p>"

    display(HTML(html))

highlight_missing_keywords(job_text, resume_text)

import google.generativeai as genai

# Use your Gemini API key
genai.configure(api_key=st.secrets["GEMINI_API_KEY"])
model = genai.GenerativeModel("models/gemini-2.5-pro-exp-03-25")

def find_jobs_from_resume(resume_text):
    prompt = f"""
You are a job search assistant for data science roles. Based on the following resume:

{resume_text}

Suggest:
1. 3‚Äì5 job titles the candidate should apply for
2. What companies are likely hiring for these roles (based on typical industry demand)
3. 2 job search platforms where these roles are often posted
4. Keywords the candidate should include in their search

Give practical, clear suggestions.
"""
    response = model.generate_content(prompt)
    return response.text

job_suggestions = find_jobs_from_resume(resume_text)
print(job_suggestions)

!pip install streamlit pyngrok

# üß† Required NLP tools
import nltk
from nltk.tokenize import word_tokenize
from nltk.corpus import stopwords

nltk.download('punkt')
nltk.download('stopwords')

# ‚úÖ Extract keywords from text
def extract_keywords(text):
    stop_words = set(stopwords.words('english'))
    words = word_tokenize(text.lower())
    keywords = [word for word in words if word.isalpha() and word not in stop_words]
    return set(keywords)

# ‚úÖ Score how many JD keywords appear in resume
def get_keyword_match_score(jd_text, resume_text):
    jd_keywords = extract_keywords(jd_text)
    resume_keywords = extract_keywords(resume_text)
    matched = jd_keywords.intersection(resume_keywords)
    return len(matched) / len(jd_keywords) if jd_keywords else 0

# ‚úÖ Weighted ATS-style score
def get_weighted_score(cosine_score, jd_text, resume_text):
    keyword_score = get_keyword_match_score(jd_text, resume_text)
    return 0.6 * cosine_score + 0.4 * keyword_score

!pip install PyPDF2

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import google.generativeai as genai
# from sklearn.metrics.pairwise import cosine_similarity
# from nltk.corpus import stopwords
# import streamlit as st
# import nltk
# from nltk.tokenize import word_tokenize
# from nltk.corpus import stopwords
# from sklearn.metrics.pairwise import cosine_similarity
# import google.generativeai as genai
# from PyPDF2 import PdfReader
# 
# nltk.download('punkt')
# nltk.download('stopwords')
# 
# 
# # Configure Gemini
# genai.configure(api_key=st.secrets["GEMINI_API_KEY"])
# embed_model = "models/embedding-001"
# text_model = genai.GenerativeModel("models/gemini-2.5-pro-exp-03-25")
# 
# # Function to extract keywords from text
# def extract_keywords(text):
#     stop_words = set(stopwords.words('english'))
#     words = word_tokenize(text.lower())
#     keywords = [word for word in words if word.isalpha() and word not in stop_words]
#     return set(keywords)
# 
# # Function to calculate keyword match score
# def get_keyword_match_score(jd_text, resume_text):
#     jd_keywords = extract_keywords(jd_text)
#     resume_keywords = extract_keywords(resume_text)
#     matched = jd_keywords.intersection(resume_keywords)
#     return len(matched) / len(jd_keywords) if jd_keywords else 0
# 
# # Function to calculate weighted ATS-style score
# def get_weighted_score(cosine_score, jd_text, resume_text):
#     keyword_score = get_keyword_match_score(jd_text, resume_text)
#     return 0.6 * cosine_score + 0.4 * keyword_score
# 
# # Function to get embeddings
# def get_embedding(text):
#     response = genai.embed_content(model=embed_model, content=text, task_type="RETRIEVAL_DOCUMENT")
#     return response['embedding']
# 
# # Function to calculate cosine similarity
# def get_similarity_score(emb1, emb2):
#     return cosine_similarity([emb1], [emb2])[0][0]
# 
# # Function to generate feedback
# def get_feedback(resume, jd):
#     prompt = f"""
# Compare the following resume and job description:
# 
# Resume:
# {resume}
# 
# Job Description:
# {jd}
# 
# Provide:
# - A match score (0‚Äì100)
# - Missing skills
# - Format improvement tips
# - Summary of strengths and weaknesses
# """
#     return text_model.generate_content(prompt).text
# 
# # Function to suggest jobs
# def find_jobs(resume):
#     prompt = f"""
# Given this resume:
# 
# {resume}
# 
# Suggest:
# 1. 3‚Äì5 job titles this person should apply for
# 2. Companies hiring these roles
# 3. Best job boards
# 4. Search keywords
# """
#     return text_model.generate_content(prompt).text
# 
# # Streamlit UI
# st.title("AI Job Prep Assistant")
# 
# # File uploader for PDF resumes
# uploaded_file = st.file_uploader("Upload your Resume (PDF format)", type="pdf")
# 
# # Text area for job description
# jd = st.text_area("Paste Job Description")
# 
# # Initialize resume_text variable
# resume_text = ""
# 
# # Extract text from uploaded PDF
# if uploaded_file is not None:
#     try:
#         pdf_reader = PdfReader(uploaded_file)
#         for page in pdf_reader.pages:
#             resume_text += page.extract_text()
#         st.success("‚úÖ Resume uploaded and text extracted successfully.")
#     except Exception as e:
#         st.error(f"‚ùå Error reading PDF file: {e}")
# 
# # Analyze & Score button
# if st.button("Analyze & Score"):
#     if resume_text and jd:
#         st.session_state.r_emb = get_embedding(resume_text)
#         st.session_state.jd_emb = get_embedding(jd)
#         score = get_similarity_score(st.session_state.r_emb, st.session_state.jd_emb)
#         feedback = get_feedback(resume_text, jd)
#         st.success(f"‚úÖ Match Score: {score*100:.2f}%")
#         st.markdown("### üìã Feedback")
#         st.write(feedback)
#         missing_keywords = extract_keywords(jd) - extract_keywords(resume_text)
#         st.markdown("### ‚ùå Missing Keywords:")
#         st.write(", ".join(sorted(missing_keywords)))
#     else:
#         st.warning("‚ö†Ô∏è Please upload a resume and enter a job description.")
# 
# # Show Score Breakdown button
# if st.button("üìä Show Score Breakdown"):
#     if "r_emb" in st.session_state and "jd_emb" in st.session_state:
#         cosine_score = get_similarity_score(st.session_state.r_emb, st.session_state.jd_emb)
#         keyword_score = get_keyword_match_score(jd, resume_text)
#         weighted_score = get_weighted_score(cosine_score, jd, resume_text)
# 
#         st.markdown("### üîç Accuracy Dashboard")
#         st.metric("üîó Cosine Similarity", f"{cosine_score * 100:.2f}%")
#         st.metric("üß© Keyword Match", f"{keyword_score * 100:.2f}%")
#         st.metric("üèÜ Weighted ATS Score", f"{weighted_score * 100:.2f}%")
#         st.info("ATS score = 60% semantic similarity + 40% keyword overlap")
#     else:
#         st.warning("‚ùó Please run 'Analyze & Score' first.")
# 
# # # Job Finder Agent button
# # if st.button("Job Finder Agent"):
# #     if resume_text:
# #         jobs = find_jobs(resume_text)
# #         st.markdown("### üéØ Job Suggestions")
# #         st.write(jobs)
# #     else:
# #         st.warning("‚ö†Ô∏è Please upload a resume to get job suggestions.")

streamlit run app.py
